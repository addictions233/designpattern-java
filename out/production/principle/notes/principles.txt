1, 单一职责原则
There should never be more than one reason for a class to change
理解: 不同的类具备不同的职责, 各司其职.做系统设计时,如果发现一个类拥有两种职责,那么就要问一个问题:
可以将这个类分成两个类吗?如果真的有必要,那就分开,千万不要让一个类干的事情太多
总结: 一个类/接口/方法只承担一个职责

2, 开放封闭原则
Software entities like classes,modules and functions should be open for extension but closed for modifications
理解: 类,模块,函数, 对扩展是开放的,对修改是关闭的.如果要修改代码,尽量用继承或者组合的方式来扩展类的功能,
而不是直接修改类的原有代码.当然,如果能保证对整个架构不产生任何影响,那就没必要搞的那么复杂,直接修改这个类吧
总结:对类的功能改动,最好的方式是扩展其功能而不是修改其原有功能, 提高软件系统的可复用性和可维护性
实现: 用抽象来构建框架, 用实现来扩展细节

3,里氏替换原则
Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it
理解: 父类可以被子类替换,可以将代码中的父类全部替换为子类,而程序的行为没有发生变化,在使用继承时,遵循里氏替换原则,
在子类中尽量不要重写和重载父类的方法.但是要注意父类的protected方法,它们往往是希望你重写的
如果要使用继承关系，则必须严格遵循里氏替换原则
总结: 所有引用父类的地方都能透明的替换成其子类的对象

4,依赖倒置原则
High level modules should not depends upon low level modules, both should depend upon abstractions.
abstractions should not depend upon details, details should depend upon abstractions
理解: 高层模块不应该依赖于底层模块, 而是依赖于抽象, 抽象不应该依赖于细节, 而细节应该依赖于抽象, 应该面向接口编程
而不是面向实现类编程,面向实现类编程相当于就事论事,那是正向依赖;而面向接口编程,相当于透过现象看本质,抓住事物的共性,
那就是反向依赖,即依赖倒置
总结: 面向接口编程, 抽取事物的本质和共性来定义接口
实现: 功能都定义为接口, 面向接口编程, 不要面向实现编程

5,迪米特法则
Only talk to you immediate friends
理解: 迪米特法则又叫最少知道法则,一个对象应该对其它对象保持最少的了解,类与类的关系越密切,耦合度越大,为了减少类之间的耦合,
不要让一个类依赖于太多其他的类,一个类对于自己依赖的类知道的越少越好
总结: 高内聚,低耦合,只与最直接的朋友通信

6,接口隔离原则
The dependency fo one class to another oen should depend on the smallest possible interface
理解:对于类来说:一个类不应该依赖它不需要的接口,一个类对另一个类的的依赖应该建立在最小的接口上,
对于接口来说:不要对外暴露没有实际意义的接口,当需要对外暴露接口时,需要保证接口的实用性和间接性
总结:一个类对另一个类的的依赖应该建立在最小的接口上,不要对外暴露没有实际意义的接口


7,组合复用原则 Composite Reuse Principle
理解:
通常类的复用分为继承复用和组合复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
1,继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
2,子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
3,它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。

采用组合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
1,它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
2,新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
3,复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。

总结: 经理使用组合复用,不用使用继承
